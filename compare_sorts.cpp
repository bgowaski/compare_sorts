// HW3_BEN_GOWASKI.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

//#include "pch.h"
#include <random>
#include <iostream>
#include <stdlib.h> 
#include <stdio.h> 
#include <array>
#include <iterator>
#include <numeric>
#include <fstream>  
#include <stdexcept>
using namespace std;


typedef array<int, 1000> arr;

// Quicksort function declarations
int partition(arr& a, int p, int r);
int quicksort(arr& a, int p, int r);
void insertionsort(arr& a, int n);
void check_sort(arr& a);


// Global Variables
int moves = 0; // increments with each move operation
int comps = 0; // increments with each comparison operation

int main()
{
	// Derived from example of random number generation on https://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution
	std::random_device rd;  //Will be used to obtain a seed for the random number engine
	std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
	std::uniform_int_distribution<> dis(0, 100000);

	ofstream outf;
	outf.open("sort.txt");
	if (outf.fail()) {
		cerr << "Error: Could not open output file\n";
		exit(1);
	}

	// Fill BST case array
	arr BST;
	iota(begin(BST), end(BST), 0);
	// Fill WST case array
	arr WST;
	//Reverse WST using BST
	int j = 0;
	for (int i = 1000 - 1; i >= 0, --i;) {
		WST[i] = BST[j];
		j++;
	}
	// Fill random array AVG
	arr AVG;
	for (int i = 0; i < 1000; ++i)
	{
		//Use dis to transform the random unsigned int generated by gen into an int in [0, 1000]
		AVG[i] = dis(gen);
	}

	// Write copies of arrays
	arr tBST = BST;
	arr tAVG = AVG;
	arr tWST = WST;
	outf << "Type of sort algo, moves, comps, \n";
	// Quick sort BST
	moves = 0;
	comps = 0;
	quicksort(tBST, 0, 999);
	check_sort(tBST);
	cout << "Quicksort BST moves= " << moves << endl;
	cout << "Quicksort BST comps= " << comps << endl;
	outf << "Quicksort BST ," << moves << ',' << comps << ',' << endl;
	// Quick sort WST
	moves = 0;
	comps = 0;
	quicksort(tWST, 0, 999);
	check_sort(tWST);
	cout << "Quicksort WST moves= " << moves << endl;
	cout << "Quicksort WST comps= " << comps << endl;
	outf << "Quicksort WST ," << moves << ',' << comps << ',' << endl;
	// Quick sort AVG
	moves = 0;
	comps = 0;
	quicksort(tAVG, 0, 999);
	check_sort(tAVG);
	cout << "Quicksort AVG moves = " << moves << endl;
	cout << "Quicksort AVG comps = " << comps << endl;
	outf << "Quicksort AVG ," << moves << ',' << comps << ',' << endl;

	// Copy new arrays for insertion sort
	tBST = BST;
	tAVG = AVG;
	tWST = WST;

	// Insertion sort BST
	moves = 0;
	comps = 0;
	insertionsort(tBST, 1000);
	check_sort(tBST);
	cout << "Insertion sort BST moves=" << moves << endl;
	cout << "Insertion sort BST comps=" << comps << endl;
	outf << "Insertion sort BST, " << moves << ',' << comps << ',' << endl;
	moves = 0;
	comps = 0;
	// Insertion sort WST
	insertionsort(tWST, 1000);
	check_sort(tWST);
	// Print 
	cout << "Insertion sort WST moves= " << moves << endl;
	cout << "Insertion sort WST comps= " << comps << endl;
	outf << "Insertion sort WST, " << moves << ',' << comps << ',' << endl;
	// Insertion sort AVG
	moves = 0;
	comps = 0;
	insertionsort(tAVG, 1000);
	check_sort(tAVG);
	// print moves and comps
	cout << "Insertion sort AVG moves= " << moves << endl;
	cout << "Insertion sort AVG comps= " << comps << endl;
	outf << "Insertion sort AVG, " << moves << ',' << comps << ',' << endl;
	outf.close(); //Close the file at the end of your program.
}

// Implemented from pseudocode in slide 16 of lecture 7
int partition(arr& a, int p, int r)
{
	// x= A[r] as pivot (from slides)
	int x = a[r];
	for (int i = p; i < r; i++)
	{
		comps++;
		if (a[i] <= x)
		{
			swap(a[p], a[i]);
			p++;
			// A swap counts as 3 moves
			moves += 3;
		}
	}
	swap(a[p], a[r]);
	// A swap counts as 3 moves
	moves += 3;
	return p;
}

// Implemented from pseudocode in slide 16 of lecture 7
int quicksort(arr& a, int p, int r)
{
	if (p >= r)
		return 0;
	{
		int q = partition(a, p, r);
		quicksort(a, p, q - 1);
		quicksort(a, q + 1, r);
	}
}

void insertionsort(arr& a, int n) 
{
	for (int i = 1; i < n; ++i) {
		// move first value into temp
		int temp = a[i];
		int j = i;
		// Compare current value with next value
		while ((j > 0) && (temp < a[j - 1])) {
			// every while loop comparison is a comp
			comps++;
			a[j] = a[j - 1];
			// every new a[j] is a move
			moves++;
			--j;
		}
		comps++;
		a[j] = temp;
	}
}

// checks to see if sort worked
void check_sort(arr& a)
{
	for (int i = 0; i < 999; i++)
	{
		if (a[i] <= a[i + 1])
		{
			//continue
		}
		else
		{
			cout << "Failed sort!" << endl;
			return;
		}
	}
	cout << "Sort success!" << endl;
}